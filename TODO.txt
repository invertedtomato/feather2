L+C*P*

L+ VLQ Encoded length header
C* Code field, used for matching message type
P* Message payload

** I'm thinking the focus should be on FeatherStream, and allowing it to be easily attached to a NetworkStream, FileStream or SecureStream. Maybe extension methods for Socket to make the process easier?

class FeatherStream : IDisposable {
	FeatherStream(Stream underlying);
	FeatherStream(Stream underlying, Boolean isOwned);

	async TMessage Read<TMessage>(Int32 code) where TMessage : IMessage, new();
	async void Write<TMessage>(Int32 code) where TMessage : IMessage;

	static FeatherStream OpenFile(String fileName, FileAccess access);
}


** Then need to make it easy to use (don't forget SSL!)


var socket = new Socket();
socket.Connect(...);
var stream = socket.GetFeatherStream();  // ??
var secureStream = socket.GetSecureFeatherStream(); // ??

var file = File.Open(...);
file.GetFeatherStream(); // ??


public interface FeatherTCPSocket :IDisposable {
	Int32 Available {get;}
	Boolean NoDelay {get;set;}
	Int32 ReceiveBufferSize {get;set;}
	Int32 SendBufferSize {get;set;}
	
	async void Connect(EndPoint remoteEndPoint);
	async void Connect(EndPoint localEndpoint, EndPoint remoteEndPoint);

	async void Listen(Int32 port);
	async void Listen(EndPoint remoteEndPoint);

	async void Disconnect();
	
	void Close();
	
	async FeatherTCPSocket Accept();

	async TMessage Receive<TMessage>(Int32 code) where TMessage : IMessage, new();
	async void Send<TMessage>(Int32 code) where TMessage : IMessage;
}

